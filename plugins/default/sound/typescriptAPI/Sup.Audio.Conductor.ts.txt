/*
 * A class that schedules audio events, in the form of MultiSoundPlayers,
 * based on beats per phrase according to an internal metronome/interval that
 * uses the Web Audio API's clock for timing.
 *
 */

namespace Sup {
    export namespace Audio {
        export class Conductor {
            bpm: number;
            timesig: number; // beats per phrase
            beatNum: number;
            transitionBeats: Array<number>;
            transition: boolean;
            players: any; // dictionary of players
            ctx: any; // audio context
            nextBeatTime: number;
            lookaheadTime: number;
            active: boolean;
            interval: any; // the internal metronome
            logOutput: boolean;
            
            toNext: boolean;
            nextParams: any; // bpm, timesig, players

            /*
                Constructs a Conductor.

                - bpm -> beats per minute
                - timesig -> time signature (how many beats in a cycle)
                - players -> a dictionary of MultiSoundPlayers
            */
            constructor(bpm: number, timesig: number, players: any) {
                // initialize parameters
                this.initializeParams({bpm, timesig, players});

                // create audio context and setup beat time
                this.ctx = player.gameInstance.audio.getContext();
                this.nextBeatTime = this.ctx.currentTime;
                // this.updateNextBeatTime();
            }

            initializeParams(params: {bpm: number, timesig: number, players: any}) {
                // set default params
                this.beatNum = 0;
                this.lookaheadTime = 0;
                this.active = false;
                this.transition = false;
                this.toNext = false;
                this.nextParams = {};
                this.logOutput = false;

                // set params passed in
                this.bpm = params.bpm;
                this.timesig = params.timesig;
                this.transitionBeats = [];
                this.players = params.players;

                // get transition beats from players' tails
                for (var pk in this.players) {
                    let player = this.players[pk];
                    for (var beat in player.tails) {
                        this.transitionBeats.push(parseInt(beat));
                    }
                }
            }

            getPlayer(playerName): MultiSoundPlayer {
                return this.players[playerName];
            }

            /*
                Begin the Conductor's scheduling.
            */
            start() {
                let conductor = this;
                let intervalMs = 1;

                this.log("started");
                // this.nextBeatTime = this.ctx.currentTime;
                this.active = true;

                // set the interval and handle beats + players
                this.interval = Sup.setInterval(intervalMs, function() {
                    if (conductor.nextBeatTime < conductor.ctx.currentTime + conductor.lookaheadTime) {
                        conductor.updateNextBeatTime();
                        conductor.log(conductor.beatNum);

                        if (conductor.transition) {
                            let beatIndex = conductor.transitionBeats.indexOf(conductor.beatNum);
                            if (beatIndex >= 0) { // transition beat
                                conductor.playAllTails();
                                // conductor.active = false;

                                // either do nothing OR begin next section
                                // depending on active settings
                                if (conductor.toNext) {
                                    conductor.resetAllPlayers(); // reset current players
                                    conductor.initializeParams(conductor.nextParams); // then load next ones
                                    // conductor.resetAllPlayers();
                                }
                                else { // stop
                                    conductor.stop();
                                }

                                conductor.log("playing tails for beat " + conductor.beatNum);
                                conductor.beatNum = -1; // hacky
                            }
                            else {
                                // conductor.log("sorry, no tails found for beat " + conductor.beatNum);
                            }
                        } else {
                            if (conductor.beatNum <= 0) { // downbeat (allow -1 for toNexts)
                                conductor.playAllInitOrLoop();

                                conductor.log("playing downbeat!");
                                conductor.log(conductor.players);
                            }
                        }

                        // increment the beat number
                        conductor.beatNum = (conductor.beatNum + 1) % conductor.timesig;
                    }
                });
            }

            /*
                Stop the Conductor and reset params for next start().
            */
            stop() {
                this.active = false;
                Sup.clearInterval(this.interval);
                this.beatNum = 0;
                this.transition = false;
                this.log("stopped " + this.interval);
                this.resetAllPlayers();
            }

            /*
                Update the next beat time based on the latest beat time and BPM.
            */
            updateNextBeatTime() {
                let nextBeatTime = Sup.Audio.Conductor.calculateNextBeatTime(this.nextBeatTime, this.bpm);
                this.log(this.bpm);
                // this.log(this.nextBeatTime + " -> " + nextBeatTime);
                this.nextBeatTime = nextBeatTime;
            }

            playAllInitOrLoop() {
                for (var pk in this.players) {
                    let player = this.players[pk];
                    player.playInitOrLoop(this.beatNum);
                }
            }

            playAllTails() {
                for (var pk in this.players) {
                    let player = this.players[pk];
                    player.playTail(this.beatNum);
                }
            }

            resetAllPlayers() {
                for (var pk in this.players) {
                    let player = this.players[pk];
                    player.reset();
                }
            }

            setTransition(transition: boolean) {
                this.transition = transition;
            }

            setNextParams(params: {bpm: number, timesig: number, players: any}) {
                this.nextParams = params;
            }

            setToNext(toNext: boolean) {
                this.toNext = toNext;
            }

            activatePlayer(playerName: string) {
                this.players[playerName].activate();
            }

            deactivatePlayer(playerName: string) {
                this.players[playerName].deactivate();
                this.players[playerName].reset();
            }

            getSecondsLeftUntilNextDownbeat(): number {
                let beatsLeft = this.timesig - (this.beatNum % this.timesig);
                let secondsLeft = Conductor.calculateNextBeatTime(0, this.bpm) * beatsLeft;
                // return secondsLeft * 1000;
                return secondsLeft;
            }

            getMillisecondsLeftUntilNextDownbeat(): number {
                return this.getSecondsLeftUntilNextDownbeat() * 1000;
            }

            setLogOutput(logOutput: boolean) {
                this.logOutput = logOutput;
            }

            log(message?: any) {
                if (this.logOutput) {
                    Sup.log("Sup.Audio.Conductor: " + message);
                }
            }

        }

        export namespace Conductor {

            /*
                Return the next beat time (in seconds).
            */
            export function calculateNextBeatTime(beatTime: number, bpm: number): number {
                return beatTime + (60 / bpm);
            }

            // static bpmToMs(bpm) {
            //     return (60/bpm)*1000;
            // }
        }
    }
}