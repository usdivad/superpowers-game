/*
 * A class that schedules audio events, in the form of MultiSoundPlayers,
 * based on beats per phrase according to an internal metronome/interval that
 * uses the Web Audio API's clock for timing.
 *
 */

namespace Sup {
    export namespace Audio {
        export class Conductor {
            bpm: number;
            timesig: number; // beats per phrase
            beatNum: number;
            transitionBeats: Array<number>;
            transition: boolean;
            players: any; // dictionary of players
            ctx: any; // audio context
            nextBeatTime: number;
            lookaheadTime: number;
            active: boolean;
            interval: any; // the internal metronome

            /*
                Constructs a Conductor.

                - bpm -> beats per minute
                - timesig -> time signature (how many beats in a cycle)
                - transitionBeats -> list of beat numbers at which a transition is possible (based on players' tails)
                - players -> a dictionary of MultiSoundPlayers
            */
            constructor(bpm: number, timesig: number, transitionBeats: Array<number>, players: any) {
                // set default params
                this.beatNum = 0;
                this.lookaheadTime = 0;
                this.active = false;
                this.transition = false;

                // set params passed in
                this.bpm = bpm;
                this.timesig = timesig;
                this.transitionBeats = transitionBeats;
                this.players = players;

                // create audio context and setup beat time
                this.ctx = player.gameInstance.audio.getContext();
                this.nextBeatTime = this.ctx.currentTime;
                // this.updateNextBeatTime();
            }

            getPlayer(playerName): MultiSoundPlayer | SoundPlayer {
                return this.players[playerName];
            }

            /*
                Begin the Conductor's scheduling.
            */
            start() {
                let conductor = this;

                Sup.log("started");
                // this.nextBeatTime = this.ctx.currentTime;
                this.active = true;

                // set the interval and handle beats + players
                this.interval = Sup.setInterval(10, function() {
                    if (conductor.nextBeatTime < conductor.ctx.currentTime + conductor.lookaheadTime) {
                        conductor.updateNextBeatTime();
                        Sup.log(conductor.beatNum);

                        if (conductor.transition) {
                            let beatIndex = conductor.transitionBeats.indexOf(conductor.beatNum);
                            if (beatIndex >= 0) { // transition beat
                                conductor.playAllTails(conductor.beatNum);
                                // conductor.active = false;

                                // either do nothing OR begin next section
                                // depending on active settings

                                Sup.log("playing tails for beat " + conductor.beatNum);
                            }
                            else {
                                Sup.log("sorry, no tails found for beat " + conductor.beatNum);
                            }
                        } else {
                            if (conductor.beatNum == 0) { // downbeat
                                conductor.playAllInitOrLoop();

                                Sup.log("playing downbeat!");
                            }
                        }

                        // increment the beat number
                        conductor.beatNum = (conductor.beatNum + 1) % conductor.timesig;
                    }
                });
            }

            /*
                Stop the Conductor and reset params for next start().
            */
            stop() {
                this.active = false;
                Sup.clearInterval(this.interval);
                this.beatNum = 0;
                this.transition = false;
                Sup.log("stopped " + this.interval);
                this.resetAllPlayers();
            }

            /*
                Update the next beat time based on the latest beat time and BPM.
            */
            updateNextBeatTime() {
                let nextBeatTime = Sup.Audio.Conductor.calculateNextBeatTime(this.nextBeatTime, this.bpm);
                // Sup.log(this.nextBeatTime + " -> " + nextBeatTime);
                this.nextBeatTime = nextBeatTime;
            }

            playAllInitOrLoop() {
                for (var pk in this.players) {
                    let player = this.players[pk];
                    player.playInitOrLoop();
                }
            }

            playAllTails(beatNum: number) {
                for (var pk in this.players) {
                    let player = this.players[pk];
                    player.playTail(beatNum);
                }
            }

            resetAllPlayers() {
                for (var pk in this.players) {
                    let player = this.players[pk];
                    player.reset();
                }
            }

            setTransition(transition: boolean) {
                this.transition = transition;
            }

        }

        export namespace Conductor {

            /*
                Return the next beat time (in seconds).
            */
            export function calculateNextBeatTime(beatTime: number, bpm: number): number {
                return beatTime + (60 / bpm);
            }

            // static bpmToMs(bpm) {
            //     return (60/bpm)*1000;
            // }
        }
    }
}