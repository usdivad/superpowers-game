/*
 * A music conductor that schedules audio events, in the form of MultiSoundPlayers,
 * based on beats per phrase according to an internal metronome/interval that
 * uses the Web Audio API's clock for timing.
 *
 */

namespace Sup {
    export namespace Audio {
        export class Conductor {
            bpm: number;
            timesig: number; // beats per phrase
            beatNum: number;
            transitionBeats: Array<number>;
            transition: boolean;
            players: any; // dictionary of players
            ctx: any; // audio context
            nextBeatTime: number;
            lookaheadTime: number;
            active: boolean;
            interval: any; // the internal metronome
            intervalMs: number;
            logOutput: boolean;
            
            toNext: boolean;
            nextParams: any; // bpm, timesig, players

            /*
                Constructs a Conductor.

                - bpm -> beats per minute
                - timesig -> time signature (how many beats in a cycle)
                - players -> a dictionary of MultiSoundPlayers
            */
            constructor(bpm: number, timesig: number, players: any) {
                // initialize parameters
                this.initializeParams({bpm, timesig, players});

                // create audio context and setup beat time
                this.ctx = player.gameInstance.audio.getContext();
                this.nextBeatTime = this.ctx.currentTime;
                // this.updateNextBeatTime();
            }

            initializeParams(params: {bpm: number, timesig: number, players: any}) {
                // set default params
                this.beatNum = 0;
                this.lookaheadTime = 0;
                this.active = false;
                this.transition = false;
                this.toNext = false;
                this.nextParams = {};
                this.logOutput = false;
                this.intervalMs = 1;

                // set params passed in
                this.bpm = params.bpm;
                this.timesig = params.timesig;
                this.transitionBeats = [];
                this.players = params.players;

                // get transition beats from players' tails
                for (var pk in this.players) {
                    let player = this.players[pk];
                    for (var beat in player.tails) {
                        this.transitionBeats.push(parseInt(beat));
                    }
                }
            }

            getPlayer(playerName): MultiSoundPlayer {
                return this.players[playerName];
            }

            /*
                Begin the Conductor's scheduling.
            */
            start() {
                let conductor = this;

                this.log("started");
                // this.nextBeatTime = this.ctx.currentTime;
                this.active = true;

                // set the interval and handle beats + players
                this.interval = Sup.setInterval(this.intervalMs, function() {
                    if (conductor.nextBeatTime < conductor.ctx.currentTime + conductor.lookaheadTime) {
                        conductor.updateNextBeatTime();
                        conductor.log(conductor.beatNum);

                        if (conductor.transition) {
                            let beatIndex = conductor.transitionBeats.indexOf(conductor.beatNum);
                            if (beatIndex >= 0) { // transition beat
                                conductor.playAllTails();
                                // conductor.active = false;

                                // either do nothing OR begin next section
                                // depending on active settings
                                if (conductor.toNext) {
                                    conductor.resetAllPlayers(); // reset current players
                                    conductor.initializeParams(conductor.nextParams); // then load next ones
                                    // conductor.resetAllPlayers();
                                }
                                else { // stop
                                    conductor.stop();
                                }

                                conductor.log("playing tails for beat " + conductor.beatNum);
                                conductor.beatNum = -1; // hacky
                            }
                            else {
                                // conductor.log("sorry, no tails found for beat " + conductor.beatNum);
                            }
                        } else {
                            if (conductor.beatNum <= 0) { // downbeat (allow -1 for toNexts)
                                conductor.playAllInitOrLoop();

                                conductor.log("playing downbeat!");
                                conductor.log(conductor.players);
                            }
                        }

                        // increment the beat number
                        conductor.beatNum = (conductor.beatNum + 1) % conductor.timesig;
                    }
                });
            }

            /*
                Stop the Conductor and reset params for next start().
            */
            stop() {
                this.active = false;
                Sup.clearInterval(this.interval);
                this.beatNum = 0;
                this.transition = false;
                this.log("stopped " + this.interval);
                this.resetAllPlayers();
            }

            /*
                Update the next beat time based on the latest beat time and BPM.
            */
            updateNextBeatTime() {
                let nextBeatTime = Sup.Audio.Conductor.calculateNextBeatTime(this.nextBeatTime, this.bpm);
                // this.log(this.bpm);
                // this.log(this.nextBeatTime + " -> " + nextBeatTime);
                this.nextBeatTime = nextBeatTime;
            }

            playAllInitOrLoop() {
                for (var pk in this.players) {
                    let player = this.players[pk];
                    player.playInitOrLoop(this.beatNum);
                }
            }

            playAllTails() {
                for (var pk in this.players) {
                    let player = this.players[pk];
                    player.playTail(this.beatNum);

                    // player.init.stop();
                    // player.loop.stop();
                }
            }

            resetAllPlayers() {
                for (var pk in this.players) {
                    let player = this.players[pk];
                    player.reset();
                }
            }

            setTransition(transition: boolean) {
                this.transition = transition;
            }

            setNextParams(params: {bpm: number, timesig: number, players: any}) {
                this.nextParams = params;
            }

            setToNext(toNext: boolean) {
                this.toNext = toNext;
            }

            isTransitioning(): boolean {
                return this.transition;
            }

            activatePlayer(playerName: string) {
                if (this.players[playerName]) {
                    this.players[playerName].activate();
                }
                else {
                    this.log("activatePlayer: no player named " + playerName + " found!");
                }
            }

            deactivatePlayer(playerName: string) {
                if (this.players[playerName]) {
                    this.players[playerName].deactivate();
                    this.players[playerName].reset();
                }
              else {
                    this.log("deactivatePlayer: no player named " + playerName + " found!");
                }
            }

            activatePlayers(playerNames: Array<string>) {
                for (var playerName of playerNames) {
                    this.activatePlayer(playerName);
                }
            }

            deactivatePlayers(playerNames: Array<string>) {
                for (var playerName of playerNames) {
                    this.deactivatePlayer(playerName);
                }
            }

            fadePlayer(playerName: string, targetVolume: number, fadeLength: number /* in ms */) {
                if (this.players[playerName]) {
                    this.players[playerName].fade(targetVolume, fadeLength);
                }
                else {
                    this.log("fadePlayer: no player named " + playerName + " found!");
                }
            }

            fadePlayers(playerNames: Array<string>, targetVolume: number, fadeLength: number) {
                for (var playerName of playerNames) {
                    this.fadePlayer(playerName, targetVolume, fadeLength);
                }
            }

            fadeAllPlayers(targetVolume: number, fadeLength: number) {
                for (var pk in this.players) {
                    this.fadePlayer(pk, targetVolume, fadeLength);
                }
            }

            getContext(): any {
                return this.ctx;
            }

            getBeatNum(): number {
                return this.beatNum;
            }

            getBpm(): number {
                return this.bpm;
            }

            getSecondsLeftUntilNextDownbeat(bpmIn?: number): number {
                let bpm = this.bpm;
                if (bpmIn) {
                    bpm = bpmIn;
                }
                // this.log("bpm is " + bpm);
                let beatsLeft = this.timesig - this.beatNum;
                let secondsLeft = Conductor.calculateNextBeatTime(0, bpm) * beatsLeft;
                // return secondsLeft * 1000;
                return secondsLeft;
            }

            getMillisecondsLeftUntilNextDownbeat(bpmIn?: number): number {
                return this.getSecondsLeftUntilNextDownbeat(bpmIn) * 1000;
            }

            getMillisecondsLeftUntilNextTransitionBeat(): number {
                if (this.transitionBeats.length < 1) {
                    this.log("no transition beats!");
                    return -1;
                }

                let numericComparison = function(a, b) {
                    return a - b;
                };
                let tbSorted = this.transitionBeats.slice().sort(numericComparison);
                tbSorted.push(tbSorted[0] + this.timesig); // add first transition beat of next cycle
                // let nextTransitionBeat = tbSorted[tbSorted.length-1];
                tbSorted.reverse();

                let nextTransitionBeat = tbSorted[0];
                for (var i = 0; i < tbSorted.length; i++) {
                    if (tbSorted[i] > this.beatNum) {
                        nextTransitionBeat = tbSorted[i];
                    }
                }
                this.log("current beat: " + this.beatNum + ", nextTransitionBeat: " + nextTransitionBeat);
                
                let beatsLeft = nextTransitionBeat - this.beatNum;
                if (beatsLeft < 0) {
                    beatsLeft *= -1;
                }
                let secondsLeft = Conductor.calculateNextBeatTime(0, this.bpm) * beatsLeft;
                return secondsLeft * 1000;
            }

            scheduleEvent(msFromNow: number, event: any) {
                let ctx = this.ctx;
                let eventTime = this.ctx.currentTime + (msFromNow / 1000);
                let eventInterval = Sup.setInterval(this.intervalMs, function() {
                    // Sup.log(eventTime + ", " + ctx.currentTime);
                    if (eventTime < ctx.currentTime) {
                        event();
                        Sup.clearInterval(eventInterval);
                    }
                });
                Sup.log("scheduling");
            }

            setLogOutput(logOutput: boolean) {
                this.logOutput = logOutput;
            }

            log(message?: any) {
                if (this.logOutput) {
                    Sup.log("Sup.Audio.Conductor: " + message);
                }
            }

        }

        export namespace Conductor {

            /*
                Return the next beat time (in seconds).
            */
            export function calculateNextBeatTime(beatTime: number, bpm: number): number {
                return beatTime + (60 / bpm);
            }

            // static bpmToMs(bpm) {
            //     return (60/bpm)*1000;
            // }
        }
    }
}