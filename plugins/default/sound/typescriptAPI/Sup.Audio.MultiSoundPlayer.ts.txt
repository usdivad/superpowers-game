/*
 * A class, comprised of multiple SoundPlayers, that provides methods for
 * smoother and more robust game audio in the form of an "init, loop, tail(s)"
 * scheme.
 *
 */

namespace Sup {
    export namespace Audio {
        export class MultiSoundPlayer {
            init: SoundPlayer;
            loop: SoundPlayer;
            tails: any;
            originalLoopSetting: boolean;
            // soundPlayers: any;
            volume: number;
            playMode: string; // init, loop, tail
            initPlayed: boolean;
            tailPlayed: boolean;
            active: boolean;
            logOutput: boolean;

            /*
                Constructs a MultiSoundPlayer.
            */
            constructor(init: string | Sound, loop: string | Sound, tails: any /* object or string */, volume = 1.0, options?: { loop?: boolean; pitch?: number; pan?: number; active?: boolean; logOutput?: boolean;}) {
                this.init = new SoundPlayer(init, volume, options);
                this.loop = new SoundPlayer(loop, volume, options);
                // this.loop = new SoundPlayer(loop, volume, {loop: true});
                this.originalLoopSetting = false;
                if ("loop" in options) {
                    this.originalLoopSetting = options.loop;
                }

                // for multiple tails corresponding to multiple beats
                this.tails = {};
                if (typeof tails == "object") {
                    for (var beatNum in tails) {
                        let tailAudio = tails[beatNum];
                        this.tails[beatNum] = new SoundPlayer(tailAudio, volume, options);
                    }
                }
                else if (typeof tails == "string" || typeof tails == "Sound") { // default to beat 0
                    this.tails[0] = new SoundPlayer(tails, volume, options);
                }

                this.volume = volume;

                // this.soundPlayers = {
                //     init: this.init,
                //     loop: this.loop,
                //     tails: this.tails
                // };

                this.playMode = "init";
                this.initPlayed = false;
                this.tailPlayed = false;

                // properties adjustable by optional params
                this.active = true;
                this.logOutput = false;

                if (options) {
                    if ("active" in options) {
                        this.active = options.active;
                    }

                    if ("logOutput" in options) {
                        this.logOutput = options.logOutput;
                    }
                }

            }

            /*
                Play the appropriate sound (init, loop, or tail).
            */
            play(beatNum=0) {
                this.log("please use playInitOrLoop() or playTail()");
                
                // if (this.active) {
                //     if (this.playMode == "init") {
                //         this.init.play();
                //     }
                //     else if (this.playMode == "loop") {
                //         if (!this.loop.getLoop() || !this.loop.isPlaying()) {
                //             this.loop.play();
                //         }
                //     }
                //     else if (this.playMode == "tail") {
                //         this.tails[beatNum].play();
                //     }
                //     else {
                //         this.log(this.playMode + " is not a valid playMode");
                //     }
                // }
            }

            playInitOrLoop(beatNum=0) {
                if (this.active) {
                    if (this.initPlayed) {
                        if (!this.loop.getLoop()) { // {loop: false}; retrigger every time
                            this.loop.stop(); // calling play() on SoundPlayer won't do anything if it's already playing, so we must stop it first
                            this.loop.play();
                            this.log("playing loop");
                        }
                        else if (!this.loop.isPlaying) { // {loop: true}; only play if it's not already playing
                            this.loop.play();
                            this.log("playing loop");
                        }
                    }
                    else {
                        this.init.play();
                        this.initPlayed = true;
                        this.log("playing init");
                        this.playMode = "loop";
                    }
                }
                else {
                    // this.init.stop();
                    // this.loop.stop();
                }

                // else {
                //     if (!this.tailPlayed) {
                //         this.playTail(beatNum);
                //     }
                // }
            }

            playTail(beatNum=0) {
                // stop init and loop
                this.init.stop();
                this.loop.stop();
                this.loop.setLoop(false); // stop loop from continuing

                // play tail
                if (this.active) {
                    if (beatNum in this.tails) {
                        this.tails[beatNum].play(); // play tail sample
                        this.tailPlayed = true;
                        this.log("playing tail");
                    }
                    else {
                        let keys = [];
                        for (var key in this.tails) {
                            keys.push(key);
                        }
                        if (keys.length == 1 && 0 in this.tails) {
                            this.tails[0].play();// play default tail sample
                            this.tailPlayed = true;
                            this.log("playing default tail");
                        }
                    }
                }
            }

            setPlayMode(playMode: string) {
                this.playMode = playMode;
            }

            reset() {
                this.playMode = "init";
                this.initPlayed = false;
                this.tailPlayed = false;
                this.loop.setLoop(this.originalLoopSetting);
            }

            activate() {
                this.active = true;
                this.loop.setLoop(this.originalLoopSetting);
            }

            deactivate() {
                this.active = false;
                this.loop.setLoop(false);
            }

            getVolume(): number {
                return this.volume;
            }

            setVolume(volume: number) {
                this.init.setVolume(volume);
                this.loop.setVolume(volume);

                for (var beatNum in this.tails) {
                    this.tails[beatNum].setVolume(volume);
                }

                this.volume = volume;
            }

            setLogOutput(logOutput: boolean) {
                this.logOutput = logOutput;
            }

            log(message?: any) {
                if (this.logOutput) {
                    Sup.log("Sup.Audio.MultiSoundPlayer: " + message);
                }
            }

            fade(targetVolume: number, fadeLength: number /* in ms */) {
                let intervalMs = 1;

                // let volDiff = Math.abs(this.volume - targetVolume);
                let volDiff = this.volume - targetVolume;
                if (volDiff < 0) {
                    volDiff *= -1;
                }

                let step = intervalMs * volDiff / fadeLength;
                
                let direction = "up";
                if (targetVolume < this.volume) {
                    direction = "down";
                }

                let msp = this;
                let timer = Sup.setInterval(intervalMs, function() {
                    if (direction == "up") {
                        if (msp.volume >= targetVolume) {
                            clearInterval(timer);
                            msp.log("fade " + timer + " done");
                        }
                        else {
                            msp.setVolume(msp.volume);
                            msp.volume += step;
                        }
                    }
                    else if (direction == "down") {
                        if (msp.volume <= targetVolume) {
                            clearInterval(timer);
                            msp.log("fade " + timer + " done");
                        }
                        else {
                            msp.setVolume(msp.volume);
                            msp.volume -= step;
                        }
                    }
                });
            }
        }
    }
}